/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.appkim.i18nstrings.plugin

import com.android.build.gradle.BaseExtension
import com.appkim.i18nstrings.AndroidParser
import com.appkim.i18nstrings.CodeInfo
import com.appkim.i18nstrings.utils.Log
import com.appkim.i18nstrings.utils.I18nLogger
import kotlinx.coroutines.runBlocking
import org.gradle.api.Plugin
import org.gradle.api.Project
import java.io.File
import java.io.PrintWriter
import java.io.StringWriter

/**
 * Gradle plugin for multilingual translation
 */
class I18nStringsPlugin: Plugin<Project> {

    private val suggestLanguages = listOf("zh-rCN", "fr","de","id","ja", "pt","es")

    private val parser = AndroidParser()
    override fun apply(project: Project) {

        Log.i18nLogger = PluginLogger(project.logger)

        try {

            // Defining Custom Extended Properties
            val extension = project.extensions.create("i18nStrings", I18nStringsExtension::class.java)

            // Register a task
            project.tasks.register("i18nStrings") { task ->
                task.doLast {

                    val moduleResMap = getModuleResMap(project, extension.excludeProjects)
                    var releaseCodes = getCodes(moduleResMap[project.name]!!, extension.release)
                    val betaCodes = getCodes(moduleResMap[project.name]!!, extension.beta)
                    //val assetsPath = getAssetsPath(project, extension.assetsPath)
                    val assetsPath = getAssetsPath(project)
                    val betaPath = getBetaPath(project, extension.betaPath)

                    Log.d("releaseCodes: $releaseCodes")
                    Log.d("betaCodes: $betaCodes")
                    Log.d("moduleResMap: $moduleResMap")
                    Log.d("assetsPath: $assetsPath")
                    Log.d("betaPath: $assetsPath")

                    val betaSet = betaCodes.toHashSet()
                    releaseCodes = releaseCodes.filter { !betaSet.contains(it) }

                    var check = true
                    var errorStr = ""
                    if(releaseCodes.isEmpty() && betaCodes.isEmpty()) {
                        errorStr += "releaseCodes and betaCodes is empty\n"
                        check = false
                    }

                    if(moduleResMap.isEmpty()) {
                        errorStr += "project modules is empty\n"
                        check = false
                    }

                    if(betaCodes.isNotEmpty() && betaPath.isEmpty()) {
                        errorStr += "can't find betaPath \n"
                        check = false
                    }

                    if(check) {
                        runBlocking {
                            try {

                                AndroidParser.onlySupportedStringsXml = extension.onlySupportedStringsXml
                                AndroidParser.excludeXmls = extension.excludeXmls.split(",").map { it.trim() }.filter { it.isNotEmpty() }

                                parser.updateProject(releaseCodes,
                                    betaCodes,
                                    project.name,
                                    moduleResMap,
                                    assetsPath,
                                    betaPath)
                            } catch (e: Exception) {
                                Log.e("i18nStrings fails, error log: ")
                                Log.e(e)
                            }
                        }
                    } else {
                        Log.e(errorStr)
                    }

                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
            Log.e(e.toString())
        }

    }

    private fun getBetaPath(project: Project, configPath: String): String {
        if(configPath.isEmpty()) return getAssetsPath(project)
        val path = project.projectDir.absolutePath + File.separator + configPath
        val dir = File(path)
        if(!dir.exists()) dir.mkdirs()
        return path
    }

    private fun getAssetsPath(project: Project): String {
        try {
            // Get the extension object of the Android plugin
            val androidExtension = project.extensions.getByType(BaseExtension::class.java)

            // Get the resource catalog for the main source set
            val mainSourceSet = androidExtension.sourceSets.getByName("main")

            return mainSourceSet.assets.srcDirs.first().absolutePath
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return ""
    }

    /**
     * Define custom extended attribute classes
     */
    open class I18nStringsExtension {
        //default translation support language, if not set, read the multilingual directory that already exists under the app module as the default value
        //suggest Recommended languages: Simplified Chinese, French, German, Indonesian, Japanese, Portuguese, Spanish.
        //all All supported languages, a total of more than 100 languages, 600 pieces of text content, translation time is estimated to be 1-2 hours, it is recommended to use suggest
        //Customize the language, use the " sign to separate, e.g.: "zh-CN,fr,de,id,ja,pt,es".
        var release: String = "default"
        var beta: String = "none"
        var betaPath: String = ""
        var onlySupportedStringsXml: Boolean = true
        var excludeXmls: String = ""
        var excludeProjects: String = ""
    }

    private fun splitCodes(text: String): List<String> {

        return text.split(",")
            .map { it.trim() }
            .filter { it.isNotEmpty() }
    }

    private fun getModuleResMap(project: Project, excludeProjectText: String): Map<String, List<String>> {

        val excludeProjectsMap = excludeProjectText.split(",").map { it.trim() }.toHashSet()
        val retMap = HashMap<String, List<String>>()

        val rootProject = project.rootProject
        val subprojects = rootProject.subprojects
        for (subproject in subprojects) {
            if(excludeProjectsMap.contains(subproject.name)) {
                continue
            }
            try {
                // Get the extension object of the Android plugin 获取 Android 插件的扩展对象
                val androidExtension = subproject.extensions.getByType(BaseExtension::class.java)

                // Get the resource catalog for the main source set 获取 main 源集的资源目录
                val mainSourceSet = androidExtension.sourceSets.getByName("main")

                retMap[subproject.name] = mainSourceSet.res.srcDirs.map { it.absolutePath }
            } catch (e: Exception) {
                Log.d("displayName: ${subproject.displayName} name: ${subproject.name} error: ${e.message}")
            }
        }

        println(retMap)

        return retMap
    }

    fun getCodes(resDirPaths: List<String>, text: String): List<CodeInfo> {

        val retCodes = mutableListOf<CodeInfo>()

        Log.d("getLanguage: $text")

        when(text) {
            "default" -> {
                retCodes.addAll(parser.getCodeInfosFromRes(resDirPaths))
            }
            "suggest" -> {
                suggestLanguages.forEach{
                    retCodes.add(CodeInfo.fromResCode(it))
                }
            }
            "all" -> {
                CodeInfo.codes.forEach {
                    retCodes.add(CodeInfo.fromCode(it))
                }
            }
            "none" -> {
                //do nothing
            }
            else -> {
                splitCodes(text).forEach{
                    val codeInfo = CodeInfo.fromResCode(it)
                    retCodes.add(codeInfo)
                }
            }
        }
        return retCodes
    }

    class PluginLogger(val logger: org.gradle.api.logging.Logger): I18nLogger() {
        override fun debug(message: String) {
            logger.debug(message)
        }

        override fun info(message: String) {
            println(message)
            //logger.info(message)
        }

        override fun warn(message: String) {
            println(message)
            //logger.warn(message)
        }

        override fun error(message: String) {
            println(message)
            //logger.error(message)
        }

        override fun error(e: Exception) {
            val sw = StringWriter()
            e.printStackTrace(PrintWriter(sw))
            val exceptionAsString = sw.toString()
            Log.e(exceptionAsString)
            error(exceptionAsString)
        }
    }
}
